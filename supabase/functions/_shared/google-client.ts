import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const GOOGLE_CLIENT_ID = Deno.env.get('Client_id') || Deno.env.get('GOOGLE_CLIENT_ID')!;
const GOOGLE_CLIENT_SECRET = Deno.env.get('Client_Secret') || Deno.env.get('GOOGLE_CLIENT_SECRET')!;
const SUPABASE_URL = Deno.env.get('SUPABASE_URL')!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;

// Validate session ID format to prevent enumeration attacks
// Must match the format generated by google-auth: session_<64 hex chars>
export function validateUserId(userId: string): boolean {
  // Session IDs are 64 hex characters prefixed with "session_"
  const sessionPattern = /^session_[a-f0-9]{64}$/;
  return sessionPattern.test(userId);
}

export async function getAccessToken(userId: string): Promise<string> {
  // Validate userId format before database query
  if (!validateUserId(userId)) {
    throw new Error('Invalid session');
  }

  const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
  
  const { data: tokenData, error } = await supabase
    .from('oauth_tokens')
    .select('*')
    .eq('user_id', userId)
    .maybeSingle();

  if (error || !tokenData) {
    throw new Error('Session not found');
  }

  // Check if token is expired (with 5 min buffer)
  if (tokenData.expiry_date && tokenData.expiry_date < Date.now() + 300000) {
    if (!tokenData.refresh_token) {
      throw new Error('Session expired');
    }

    const refreshResponse = await fetch('https://oauth2.googleapis.com/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        client_id: GOOGLE_CLIENT_ID,
        client_secret: GOOGLE_CLIENT_SECRET,
        refresh_token: tokenData.refresh_token,
        grant_type: 'refresh_token',
      }),
    });

    const newTokens = await refreshResponse.json();

    if (newTokens.error) {
      throw new Error('Session expired');
    }

    await supabase
      .from('oauth_tokens')
      .update({
        access_token: newTokens.access_token,
        expiry_date: Date.now() + (newTokens.expires_in * 1000),
      })
      .eq('user_id', userId);

    return newTokens.access_token;
  }

  return tokenData.access_token;
}

export async function googleFetch(userId: string, url: string, options: RequestInit = {}) {
  const accessToken = await getAccessToken(userId);
  
  const response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${accessToken}`,
    },
  });

  return response;
}
